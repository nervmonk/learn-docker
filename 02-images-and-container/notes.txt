Difference between images and container
- images: Blueprint, where the code and config lives
- Container: Running instances

Add interactivity on container by adding -it flag, e.g: docker run -it node


Creating images from Dockerfile:
- docker build .

Checking docker images:
- docker ps -a

Run the container:
- docker run -p <host-port>:<docker-port> <container-id or name>

In nodejs app example, when you've made a change in server.js code and restarting the container, your change will not be reflected in the running container.
Why?
- Images are actually locked and finishes once you finish build them. It's read only and can't be edited from the outside
- If you change anything in part of your blueprint, you have to rebuild it


DOCKER LAYER BASED ARCHITECTURE
- Think one layer of one command in your Dockerfile. when one layer change, all the subsequent layer will be re-executed (no caching), so orders matter in context of image rebuilding speed


need help?
- docker --help

command
managing images and containers
- docker ps : list all the running container
- docker ps -a : list all the containers, including stopped containers

- docker run: create new container based on an image
- docker start: restarting stopped container


detaching and attaching
- docker -d (detach)
- docker attach <container_name>


interactive mode
- docker run -it

Deleting images and container
container:
- docker rm <container_name> (You can't remove running container)
- docker container prune
images:
- docker rmi <image id> (notes: you can only remove images if they're not getting used by any container anymore, including stopped container)
- docker images prune


Images
- docker images (List all existing images)

2 ways of sharing your apps with Docker:
- Dockerfile
- Built Image (Docker Hub or Private Registry)